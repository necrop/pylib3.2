#-------------------------------------------------------------------------------
# Name: Catalog
# Purpose:
#
# Author: James McCracken
#-------------------------------------------------------------------------------

import re
import os
import csv
from lxml import etree

from .metadata.authors import Authors


ns = {"rdf": "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
      "rdfs": "http://www.w3.org/2000/01/rdf-schema#",
      "xsi": "http://www.w3.org/2001/XMLSchema-instance",
      "dc": "http://purl.org/dc/elements/1.1/",
      "dcterms": "http://purl.org/dc/terms/",
      "dcmitype": "http://purl.org/dc/dcmitype/",
      "cc": "http://web.resource.org/cc/",
      "pgterms": "http://www.gutenberg.org/rdfterms/"}

paths = {
    "a1": "./{%s}creator/{%s}Bag/{%s}li" % (ns["dc"], ns["rdf"], ns["rdf"],),
    "a2": "./{%s}creator" % (ns["dc"],),
    "c1": "./{%s}contributor/{%s}Bag/{%s}li" % (ns["dc"], ns["rdf"], ns["rdf"],),
    "c2": "./{%s}contributor" % (ns["dc"],),
    "t": "./{%s}title" % (ns["dc"],),
    "l": "./{%s}language/{%s}ISO639-2/{%s}value" % (ns["dc"], ns["dcterms"], ns["rdf"],),
    "d": "./{%s}created/{%s}W3CDTF/{%s}value" % (ns["dc"], ns["dcterms"], ns["rdf"],)
}

date_pat = (re.compile(r" (\d{4})\??-(\d{4})"),
            re.compile(r" (\d{4})\??-(\d{2})"),
            re.compile(r" (\d{4})\??-"),
            re.compile(r" -(\d{4})"),)

cat = []
cat_map = {}
aut = None

class Catalog(object):

    def __init__(self, catalog=None, filemap=None, genre=None, authors=None):
        self.cat_file = catalog
        self.map_file = filemap
        self.genre_file = genre
        if authors is None:
            self.authors_file = os.path.join(os.path.dirname(catalog),
                                             "authors.csv")
        else:
            self.authors_file = authors

    def parse(self):
        global cat, cat_map, aut
        tree = etree.parse(self.cat_file)
        aut = Authors(self.authors_file)
        fm = FileMap(self.map_file)
        gm = GenreMap(self.genre_file)
        cat = [CatalogEntry(n) for n in\
               tree.findall("./{%s}etext" % (ns["pgterms"],))]
        for e in cat:
            e.filepaths = fm.filepaths(e.id)
            e.genre = gm.genre(e.id)
            cat_map[e.id] = e
        cat.sort(key=lambda a: a.id)

    def entries(self):
        if not cat:
            self.parse()
        return cat

    def find(self, id):
        if not cat:
            self.parse()
        id = int(id)
        try:
            return cat_map[id]
        except KeyError:
            return None

    def english_entries(self):
        return [e for e in self.entries() if e.language == "en"]

    def untranslated_english_entries(self):
        return [e for e in self.english_entries() if\
                (not e.has_foreign_classification() and
                 not e.has_translator())]

    def linked_entries(self):
        return [e for e in self.untranslated_english_entries() if e.filepaths]

    def authors_by_frequency(self, start=None, end=None):
        authors = {}
        for e in [e for e in self.linked_entries() if\
                  e.author_dates(estimated=True)[0] is not None]:
            if (start is not None and
                e.author_dates(estimated=True)[1] < int(start)):
                continue
            if (end is not None and
                e.author_dates(estimated=True)[0] > int(end)):
                continue
            if e.author:
                if e.author in authors:
                    authors[e.author] += 1
                else:
                    authors[e.author] = 1
        afreq = []
        for j in sorted(authors.keys(), key=lambda a: authors[a], reverse=True):
            afreq.append((j, authors[j]))
        return afreq


class CatalogEntry(object):

    def __init__(self, n):
        id = n.get("{" + ns["rdf"] + "}ID").replace("etext", "")
        self.id = int(id)
        self.idpad = "%06d" % (self.id,)

        vals = [n.findtext(paths["a1"]) or n.findtext(paths["a2"]) or "",
                n.findtext(paths["t"]) or "",
                n.findtext(paths["l"]) or "",
                n.findtext(paths["d"]) or ""]
        vals = [char_decode(v) for v in vals]

        self.author = vals[0]
        self.authorObject = aut.find_by_id(self.author)
        self.title = vals[1]
        self.language = vals[2]
        self.datestamp = vals[3]

        self.contributors = [k.text for k in n.findall(paths["c1"])] or\
                            [k.text for k in n.findall(paths["c2"])]
        self.contributors = [char_decode(v) for v in self.contributors]

        self.subs = {}
        self.subs["lcsh"] = [k.text for k in\
                             n.xpath("./dc:subject//dcterms:LCSH/rdf:value",
                             namespaces=ns)]
        self.subs["lcc"] = [k.text for k in\
                            n.xpath("./dc:subject//dcterms:LCC/rdf:value",
                            namespaces=ns)]
        for t in self.subs.keys():
            self.subs[t] = [char_decode(v) for v in self.subs[t]]
        self.filepaths = []

    def author_surname(self):
        return self.authorObject.surname()

    def subjects(self, type=None):
        if type is None:
            j = self.subs["lcsh"][:]
            j.extend(self.subs["lcc"])
            return j
        else:
            type = type.lower()
            try:
                return self.subs[type]
            except KeyError:
                return []

    def has_foreign_classification(self):
        for letter in "ABCDFGHJKLMQT":
            c = "P" + letter
            if c in self.subjects(type="lcc"):
                return True
        return False

    def has_translator(self):
        for contrib in self.contributors:
            if "translator" in contrib.lower():
                return True
        return False

    def is_verse(self):
        if "poems" in self.title.lower() or "poetry" in self.title.lower():
            return True
        for subj in self.subjects(type="lcsh"):
            if "poems" in subj.lower() or "poetry" in subj.lower():
                return True
        return False

    def is_drama(self):
        if "dramatic works" in self.title.lower():
            return True
        for subj in self.subjects(type="lcsh"):
            if "drama" in subj.lower() or "tragedies" in subj.lower():
                return True
        return False

    def is_fiction(self):
        for subj in self.subjects(type="lcsh"):
            if "fiction" in subj.lower():
                return True
        for subj in self.subjects(type="lcsh"):
            if "biography" in subj.lower():
                return False
        if ("PR" in self.subjects(type="lcc") or
            "PS" in self.subjects(type="lcc") or
            "PZ" in self.subjects(type="lcc")):
                return True
        return False

    def author_dates(self):
        return self.authorObject.biodates()


class FileMap(object):

    def __init__(self, path):
        self.path = path
        self.parse()

    def parse(self):
        self.texts = {}
        reader = csv.reader(open(self.path, "rb"))
        for row in reader:
            num = int(row[0])
            loc = row[1]
            self.texts.setdefault(num, []).append(loc)

    def filepaths(self, num):
        num = int(num)
        if num in self.texts:
            return self.texts[num]
        else:
            return []


class GenreMap(object):

    def __init__(self, path):
        self.path = path
        self.parse()

    def parse(self):
        self.texts = {}
        reader = csv.reader(open(self.path, "rb"))
        for row in reader:
            if row[0] == "ID":
                continue
            num = int(row[0])
            if row[6] != "agree" and row[6] != "conflict":
                genre = row[6]
            else:
                genre = row[4]
            self.texts[num] = genre

    def genre(self, num):
        num = int(num)
        if num in self.texts:
            return self.texts[num]
        else:
            return None


def char_decode(chars):
    chars = chars.replace("\n", ": ")
    chars = chars.replace("  ", " ")
    chars = chars.replace(": (", " (")
    chars = chars.strip()
    if type(chars) is str:
        chars = chars.decode("utf-8")
    return chars
