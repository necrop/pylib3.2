"""
EntryIterator -- Dictionary entry Iterator for OED and ODE/NOAD

@author: James McCracken
"""

import re
import os
import random

from lex import lexconfig
from lex.oed.entry import Entry as OedEntry
from lex.odo.entry import Entry as OdoEntry

ENTRY_PATTERNS = {'oed': re.compile('^<Entry[ >]'),
                  'odo': re.compile('^<e[ >]')}
DEFAULT_OUTPUT_ROOT = 'Dictionary'
OUTPUT_HEADER = '<?xml version="1.0" encoding="UTF-8"?>\n'


class EntryIterator(object):

    """
    Dictionary entry Iterator (suitable for OED and ODE/NOAD)

    EntryIterator.iterate() yields a sequence of OED or ODE entry objects
    (lex.oed.entry.Entry or lex.ode.entry.Entry).

    Usage:
    >>> iterator = EntryIterator(path='/path/to/data/',
                                 dict_type='oed',
                                 verbosity='low',
                                 fix_ligatures=True,
                                 random_sample=15,
                                 file_filter='[A-J]_oed.xml')
    >>> for entry in iterator.iterate():
            print(entry.label())

    This assumes that the input file(s) has 1 entry per line, i.e. each line
    beginning <Entry> or <e> can be parsed as well-formed XML. This won't work
    well for input files in which entries are broken over multiple lines, or
    in which there are multiple lines per entry; it'll probably mean that
    entries get missed.

    Keyword arguments (all optional, but at least one of 'path'
    or 'dict_name' should be supplied, so that the iterator can figure
    out where to find the input files):

     -- path: A directory, a filename, or a list of filenames.
            All filenames should refer to XML files and have a .xml extension;
            any filename in the list without a .xml extension will be skipped.
            - If a directory is supplied, the list of filenames is generated by
            globbing all the .xml files in that directory.
            - If a list of filenames is supplied, the list is processed in its
            original order; it's not re-sorted.
            If no 'path' value is supplied, the iterator will use the
            'dict_name' value to look up the default path specified in
            lex.lexconfig.

     -- dict_name: Either 'oed', 'ode', or 'noad'.

     -- dict_type: Either 'oed' (for OED-model dictionary) or 'odo'
            (for ODO-type dictionary, i.e. ODE or NOAD).
            If no dict_type value is supplied, the iterator will try to
            figure this out by sampling the first few lines of the first file.

     -- verbosity: None (default), 'low', or 'high'.
            - 'low' prints the name of each file as it's opened.
            - 'high' additionally prints the ID and headword of each
            entry as it's reached.

     -- file_filter: A regular expression matching one or more of
            the files in the directory. Only files matching the regular
            expression will be processed. e.g. file_filter='oed_[GHI].xml'

     -- fix_ligatures: If True, all 'ae' and 'oe' ligatures will be
            converted to plain ASCII 'ae' and 'oe'. (OED only)

     -- output_dir: If supplied, a copy of each input file
            will be written to this directory (reflecting any changes
            made to the yielded entries).
            Note that if sampling is used (see below), only the sampled
            entries (i.e. those which have been yielded) will be written
            to the output file.

     -- output_root: Only used if an output_dir value is
            supplied. Specifies the tag name of the root node in the
            output files. Defaults to 'Dictionary'.

    Keyword arguments used for sampling:

     -- sample: An int indicating how frequently the stream of
            input entries should be sampled; e.g. sample=10 means that
            every 10th entry will be yielded.

     -- random_sample: An int indicating how frequently
            (approximately)the stream of input entries should be sampled;
            e.g. random_sample=10 means that each input entry has a
            1 in 10 chance of being yielded.

    The 'sample' and 'random_sample' keywords (if used) have a similar
    effect in sampling the input (useful when testing a slow process).
    The difference is that 'sample' gives deterministic sampling (the
    same sample set is yielded each time it's run), whereas
    'random_sample' gives probabilistic sampling (a different sample set
    is yielded each time it's run).
    """

    def __init__(self, **kwargs):
        self.verbosity = kwargs.get('verbosity', None)
        self.fix_ligatures = kwargs.get('fixLigatures') or kwargs.get('fix_ligatures', False)
        self.output_dir = kwargs.get('output_dir', None)
        self.output_root = kwargs.get('output_root', DEFAULT_OUTPUT_ROOT)

        self.dict_name = (kwargs.get('dict_name') or
                          kwargs.get('dict_type') or
                          kwargs.get('dictType') or None)
        if self.dict_name:
            self.dict_name = self.dict_name.lower()
        self.path = kwargs.get('path') or _default_source(self.dict_name)

        self.dict_type = (kwargs.get('dict_type') or
                          kwargs.get('dictType') or
                          kwargs.get('dict_name') or None)
        if self.dict_type:
            self.dict_type = self.dict_type.lower()
            if self.dict_type in ('noad', 'ode'):
                self.dict_type = 'odo'
            if self.dict_type not in ('oed', 'odo'):
                self.dict_type = None

        # Probably only used for diagnostics - if you just want to
        # process one or two files in the directory
        file_filter = kwargs.get('fileFilter') or kwargs.get('file_filter', None)
        if file_filter is not None:
            self._filecheck_pattern = re.compile(file_filter)
        else:
            self._filecheck_pattern = None

        # Sample rates
        self.sample = kwargs.get('sample', None)
        self.random_sample = kwargs.get('random_sample', None)
        self.entry_count = 0

    def files(self):
        """
        Return a list of files from the directory or directories listed
        in self.path.

        These are the files that self.iterate() will parse in turn.
        """
        try:
            return self._files
        except AttributeError:
            if isinstance(self.path, list):
                self._files = [fname for fname in self.path if
                               os.path.splitext(fname)[1] == '.xml']
            elif (os.path.isfile(self.path) and
                    os.path.splitext(self.path)[1] == '.xml'):
                self._files = [self.path]
            elif os.path.isdir(self.path):
                self._files = [os.path.join(self.path, fname) for fname in
                               sorted(os.listdir(self.path)) if
                               os.path.splitext(fname)[1] == '.xml']
            else:
                self._files = []
            self._files = [f for f in self._files if self._filecheck(f)]
            return self._files

    def _filecheck(self, filename):
        """
        Check that the filename matches the filecheck pattern (if any).
        """
        if (self._filecheck_pattern is not None and
                not self._filecheck_pattern.search(filename)):
            return False
        else:
            return True

    def file_count(self):
        """
        Return the number of files found in self.files().
        """
        return len(self.files())

    def iterate(self):
        """
        Iterate over the set of XML files, parsing each file and yielding
        one entry at a time.
        """
        if not self.dict_type:
            self.dict_type = _deduce_dict(self.files())

        self.entry_count = 0
        for filepath in self.files():
            if self.verbosity is not None:
                print('Reading %s...' % filepath)

            # Initialize output file (if any)
            if self.output_dir:
                outfile = os.path.join(self.output_dir,
                                       os.path.basename(filepath))
                output_handle = open(outfile, 'w')
                output_handle.write(OUTPUT_HEADER)
                output_handle.write('<' + self.output_root + '>\n')

            with open(filepath) as filehandle:
                for line in filehandle:
                    entry = self._parse_line(line)
                    if not entry:
                        continue

                    # Check if this entry should be skipped (e.g.
                    #  if a sample rate has been specified).
                    self.entry_count += 1
                    if self.sample and self.entry_count % self.sample:
                        continue
                    if (self.random_sample and
                            random.randint(1, self.random_sample) != 1):
                        continue

                    if self.verbosity == 'high':
                        print('\t%s\t%s' % (entry.id, entry.headword,))
                    yield entry

                    # Print to output file (if any)
                    if self.output_dir:
                        output_handle.write(entry.serialized() + '\n')

            # Close output file (if any)
            if self.output_dir:
                output_handle.write('</' + self.output_root + '>\n')
                output_handle.close()

    def _parse_line(self, line):
        """
        Parse each line to determine whether it's an entry; if so,
        use it to initialize and return an appropriate entry object.

        Otherwise return None.
        """
        line = line.strip()
        if ENTRY_PATTERNS[self.dict_type].match(line):
            if self.dict_type == 'oed':
                entry = OedEntry(line,
                                 fix_ligatures=self.fix_ligatures)
            elif self.dict_type == 'odo':
                entry = OdoEntry(line)
            return entry
        else:
            return None


def _deduce_dict(files):
    """
    Sample the start of the first file to determine whether
    this is an ODO- or OED-type entry.
    """
    odo_count, oed_count = (0, 0)
    for fname in files:
        with open(fname) as filehandle:
            for line in filehandle:
                line = line.strip()
                if ENTRY_PATTERNS['oed'].match(line):
                    oed_count += 1
                if ENTRY_PATTERNS['odo'].match(line):
                    odo_count += 1
                if odo_count == 5 or oed_count == 5:
                    break
        if odo_count == 5 or oed_count == 5:
            break
    if odo_count > oed_count:
        return 'odo'
    else:
        return 'oed'


def _default_source(dict_name):
    """
    Return a default directory to use for input, if none has been
    explicitly supplied.

    Default directories use the settings in lex.lexconfig.
    """
    if dict_name.lower() == 'oed':
        source = lexconfig.OEDLATEST_TEXT_DIR
    elif dict_name.lower() == 'ode':
        source = lexconfig.ODE_TEXT_DIR
    elif dict_name.lower() == 'noad':
        source = lexconfig.NOAD_TEXT_DIR
    else:
        source = ''
    return source
